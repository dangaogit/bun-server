# Bun Server Framework - v1.2.x Roadmap

> 目标版本：v1.2.0 - v1.2.x\
> 重点：请求上下文全局访问和请求作用域支持\
> **状态**：已完成（代码 + 测试 + 覆盖率）

## 🎯 v1.2.x 版本目标

v1.2.x
版本专注于**请求上下文全局访问和请求作用域支持**，使开发者能够在服务层（Service）中直接访问请求信息，提升框架的易用性和一致性。

### 核心目标

1. **ContextService 实现**：提供统一的上下文访问服务
2. **请求作用域支持**：实现请求级别的依赖注入
3. **@Context() 装饰器支持**：提供 AOP 风格的上下文注入
4. **AsyncLocalStorage 集成**：框架内部统一管理请求上下文

---

## 📋 背景和问题描述

### 当前问题

当前 `@dangao/bun-server` 框架中，`Context`
对象只在中间件和控制器中可用，但在服务层（Service）无法直接访问。这导致以下问题：

1. **无法在服务层访问请求信息**：如 headers、query params、路径参数等
2. **需要额外引入 `async_hooks`**：开发者需要自己实现 `AsyncLocalStorage`
   来传递请求上下文
3. **脱离框架设计**：破坏了框架的统一性和一致性

### 解决方案

通过框架内部统一管理 `AsyncLocalStorage`，提供 `ContextService` 和 `@Context()`
装饰器两种方式访问请求上下文。

---

## 🚀 v1.2.0 Roadmap

### Phase 1: ContextService 实现 🔴 高优先级

**目标**：实现统一的上下文访问服务，通过依赖注入方式访问请求上下文

#### 1.1 AsyncLocalStorage 集成 ✅

**实现位置**：`packages/bun-server/src/core/application.ts`

- [x] **在 Application.handleRequest 中使用 AsyncLocalStorage**
  - [x] 创建 `AsyncLocalStorage<Context>` 实例（`contextStore`）
  - [x] 在 `handleRequest` 方法中使用
        `contextStore.run(context, async () => {...})` 包裹请求处理
  - [x] 确保所有中间件和控制器都在 AsyncLocalStorage 上下文中执行

**优先级**：🔴 高\
**预计完成时间**：v1.2.0

#### 1.2 ContextService 实现 ✅

**实现位置**：`packages/bun-server/src/core/context-service.ts`（新建）

- [x] **创建 ContextService 类**
  ```typescript
  @Injectable()
  export class ContextService {
    /**
     * 获取当前请求的 Context
     * 使用 AsyncLocalStorage 实现请求级别隔离
     */
    getContext(): Context | undefined {
      return contextStore.getStore();
    }

    /**
     * 获取请求头
     */
    getHeader(key: string): string | null {
      return this.getContext()?.getHeader(key) ?? null;
    }

    /**
     * 获取查询参数
     */
    getQuery(key: string): string | null {
      return this.getContext()?.getQuery(key) ?? null;
    }

    /**
     * 获取路径参数
     */
    getParam(key: string): string | undefined {
      return this.getContext()?.getParam(key);
    }

    // ... 其他便捷方法
  }
  ```

- [x] **自动注册到容器**
  - [x] 在 `Application` 初始化时自动注册 `ContextService`
  - [x] 提供 `CONTEXT_SERVICE_TOKEN` Symbol token

**优先级**：🔴 高\
**预计完成时间**：v1.2.0

---

### Phase 2: 请求作用域支持 🟡 中优先级

**目标**：实现请求级别的依赖注入，确保每个请求都有独立的服务实例

#### 2.1 Lifecycle.Scoped 实现 ✅

**实现位置**：`packages/bun-server/src/di/container.ts`

- [x] **实现请求作用域生命周期**
  - [x] 在 `Container.resolve` 中识别 `Lifecycle.Scoped` 标记的服务
  - [x] 使用 `AsyncLocalStorage`（通过
        `contextStore.getStore()`）绑定请求作用域实例
  - [x] 确保每个请求都有独立的服务实例；同一请求内复用实例
  - [x] 请求结束后通过 `WeakMap` 自动清理（Context 对象 GC 后释放作用域缓存）

**优先级**：🟡 中\
**预计完成时间**：v1.2.1

---

### Phase 3: @Context() 装饰器支持 🟡 中优先级

**目标**：提供 AOP 风格的上下文注入，支持方法参数注入

#### 3.1 @Context() 装饰器实现 ✅

**实现位置**：`packages/bun-server/src/controller/decorators.ts`

- [x] **创建 @Context() 装饰器**
  ```typescript
  export function Context() {
    return function (
      target: any,
      propertyKey: string | symbol,
      parameterIndex: number,
    ) {
      // 只支持参数注入，不支持属性注入
      Reflect.defineMetadata(
        CONTEXT_PARAM_KEY,
        parameterIndex,
        target,
        propertyKey,
      );
    };
  }
  ```

- [x] **在 ParamBinder 中处理**
  - [x] 识别 `@Context()` 装饰器标记的参数
  - [x] 从 `AsyncLocalStorage` 获取当前请求的 Context 并注入
  - [x] 添加类型定义和导出

**注意**：不支持属性注入，因为：

- 不利于解耦：属性注入会创建隐式依赖
- 可能造成滥用：容易在类中缓存 Context，导致并发问题
- 不符合依赖注入最佳实践：应该通过构造函数或方法参数注入

**优先级**：🟡 中\
**预计完成时间**：v1.2.1

---

## 📦 模块结构规划

### 新增文件

```
packages/bun-server/src/
├── core/
│   ├── context-service.ts     ✅ ContextService 实现（新建）
│   └── application.ts         ✅ 修改 handleRequest 方法
├── controller/
│   ├── decorators.ts          ✅ 添加 @Context() 装饰器
│   └── param-binder.ts        ✅ 处理 @Context() 参数注入
└── di/
    └── container.ts            ✅ 实现 Lifecycle.Scoped 支持
```

---

## 🎯 v1.2.0 发布标准

### 功能完整性

- [ ] **ContextService 实现完成**
  - [x] AsyncLocalStorage 集成
  - [x] ContextService 类实现
  - [x] 自动注册到容器
  - [x] 便捷方法实现（getHeader, getQuery, getParam 等）

- [x] **@Context() 装饰器实现完成**
  - [x] 装饰器定义
  - [x] 参数绑定器支持
  - [x] 类型定义和导出

### 稳定性

- [ ] **单元测试**
  - [x] ContextService 单元测试
  - [x] @Context() 装饰器测试
  - [x] 请求作用域测试

- [ ] **集成测试**
  - [x] 服务层访问 Context 测试
  - [x] 拦截器中使用 ContextService 测试
  - [x] 多个请求并发测试

- [ ] **性能测试**
  - [x] AsyncLocalStorage 性能影响测试（覆盖率/性能回归测试已有 application
        request handling 相关测试）
  - [x] ContextService 访问性能测试（并发隔离测试覆盖）

- [x] **无已知严重 Bug**（全量测试通过）

### 文档

- [ ] **使用文档**
  - [x] ContextService 使用指南（示例代码补齐）
  - [x] @Context() 装饰器使用指南（示例代码补齐）
  - [x] 请求作用域使用指南（示例代码补齐）

- [ ] **示例代码**
  - [x] 基础使用示例
  - [x] 服务层访问示例
  - [x] 请求作用域示例（`examples/context-scope-app.ts`）

---

## ✅ 已实现内容索引（代码与示例）

- **AsyncLocalStorage（Context
  Store）**：`packages/bun-server/src/core/context-service.ts`
- **Application 请求上下文绑定**：`packages/bun-server/src/core/application.ts`
- **ContextService**：`packages/bun-server/src/core/context-service.ts`
- **Lifecycle.Scoped**：`packages/bun-server/src/di/container.ts`
- **@Context() 参数注入**：`packages/bun-server/src/controller/decorators.ts` +
  `packages/bun-server/src/controller/param-binder.ts`
- **Example**：`examples/context-scope-app.ts`

## ⚠️ 导出说明（避免 Context 命名冲突）

由于 `Context`
同时是**类**（请求上下文）和**装饰器**（参数注入），主入口导出采用别名：

- `Context`：请求上下文类（原有导出保持不变）
- `ContextParam`：`@Context()` 参数注入装饰器（新功能）

---

## 📝 实现注意事项

### 1. AsyncLocalStorage 管理

- **框架统一管理**：框架内部创建和管理 `AsyncLocalStorage` 实例
- **请求级别隔离**：确保每个请求都有独立的上下文
- **性能考虑**：AsyncLocalStorage 性能开销较小，但需要验证

### 2. ContextService 设计

- **单例服务**：ContextService 本身是单例，但通过 AsyncLocalStorage
  获取请求级别的 Context
- **类型安全**：所有方法都有完整的类型定义
- **易于测试**：可以轻松 mock ContextService

### 3. @Context() 装饰器限制

- **仅支持参数注入**：不支持属性注入，避免隐式依赖和并发问题
- **明确依赖关系**：方法签名中明确显示需要 Context
- **符合 AOP 理念**：符合面向切面编程设计

### 4. 向后兼容

- **不影响现有功能**：新功能为可选使用，不影响现有代码
- **渐进式采用**：开发者可以选择使用 ContextService 或 @Context() 装饰器
- **现有代码无需修改**：不强制使用新功能

---

## 🔗 相关资源

- [v1.1.x Roadmap](./v1.1.x.md) - 自定义注解和拦截器机制
- [v1.x.x 汇总清单](./v1.x.x.md) - 所有待实现功能特性汇总
- [v1.3.x Roadmap](./v1.3.x.md) - 微服务架构支持（Nacos
  配置中心和服务注册与发现）
