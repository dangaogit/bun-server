# Bun Server Framework - v1.2.x Roadmap

> 目标版本：v1.2.0 - v1.2.x\
> 重点：请求上下文全局访问和请求作用域支持\
> **状态**：未开始

## 🎯 v1.2.x 版本目标

v1.2.x
版本专注于**请求上下文全局访问和请求作用域支持**，使开发者能够在服务层（Service）中直接访问请求信息，提升框架的易用性和一致性。

### 核心目标

1. **ContextService 实现**：提供统一的上下文访问服务
2. **请求作用域支持**：实现请求级别的依赖注入
3. **@Context() 装饰器支持**：提供 AOP 风格的上下文注入
4. **AsyncLocalStorage 集成**：框架内部统一管理请求上下文

---

## 📋 背景和问题描述

### 当前问题

当前 `@dangao/bun-server` 框架中，`Context`
对象只在中间件和控制器中可用，但在服务层（Service）无法直接访问。这导致以下问题：

1. **无法在服务层访问请求信息**：如 headers、query params、路径参数等
2. **需要额外引入 `async_hooks`**：开发者需要自己实现 `AsyncLocalStorage`
   来传递请求上下文
3. **脱离框架设计**：破坏了框架的统一性和一致性

### 解决方案

通过框架内部统一管理 `AsyncLocalStorage`，提供 `ContextService` 和 `@Context()`
装饰器两种方式访问请求上下文。

---

## 🚀 v1.2.0 Roadmap

### Phase 1: ContextService 实现 🔴 高优先级

**目标**：实现统一的上下文访问服务，通过依赖注入方式访问请求上下文

#### 1.1 AsyncLocalStorage 集成 ✅

**实现位置**：`packages/bun-server/src/core/application.ts`

- [ ] **在 Application.handleRequest 中使用 AsyncLocalStorage**
  - [ ] 创建 `AsyncLocalStorage<Context>` 实例
  - [ ] 在 `handleRequest` 方法中使用
        `contextStore.run(context, async () => {...})` 包裹请求处理
  - [ ] 确保所有中间件和控制器都在 AsyncLocalStorage 上下文中执行

**优先级**：🔴 高\
**预计完成时间**：v1.2.0

#### 1.2 ContextService 实现 ✅

**实现位置**：`packages/bun-server/src/core/context-service.ts`（新建）

- [ ] **创建 ContextService 类**
  ```typescript
  @Injectable()
  export class ContextService {
    /**
     * 获取当前请求的 Context
     * 使用 AsyncLocalStorage 实现请求级别隔离
     */
    getContext(): Context | undefined {
      return contextStore.getStore();
    }

    /**
     * 获取请求头
     */
    getHeader(key: string): string | null {
      return this.getContext()?.getHeader(key) ?? null;
    }

    /**
     * 获取查询参数
     */
    getQuery(key: string): string | null {
      return this.getContext()?.getQuery(key) ?? null;
    }

    /**
     * 获取路径参数
     */
    getParam(key: string): string | undefined {
      return this.getContext()?.getParam(key);
    }

    // ... 其他便捷方法
  }
  ```

- [ ] **自动注册到容器**
  - [ ] 在 `Application` 初始化时自动注册 `ContextService`
  - [ ] 提供 `CONTEXT_SERVICE_TOKEN` Symbol token

**优先级**：🔴 高\
**预计完成时间**：v1.2.0

---

### Phase 2: 请求作用域支持 🟡 中优先级

**目标**：实现请求级别的依赖注入，确保每个请求都有独立的服务实例

#### 2.1 Lifecycle.Scoped 实现 ✅

**实现位置**：`packages/bun-server/src/di/container.ts`

- [ ] **实现请求作用域生命周期**
  - [ ] 在 `Container.resolve` 中识别 `Lifecycle.Scoped` 标记的服务
  - [ ] 使用 `AsyncLocalStorage` 存储请求作用域的实例
  - [ ] 确保每个请求都有独立的服务实例
  - [ ] 请求结束后自动清理作用域实例

**优先级**：🟡 中\
**预计完成时间**：v1.2.1

---

### Phase 3: @Context() 装饰器支持 🟡 中优先级

**目标**：提供 AOP 风格的上下文注入，支持方法参数注入

#### 3.1 @Context() 装饰器实现 ✅

**实现位置**：`packages/bun-server/src/controller/decorators.ts`

- [ ] **创建 @Context() 装饰器**
  ```typescript
  export function Context() {
    return function (
      target: any,
      propertyKey: string | symbol,
      parameterIndex: number,
    ) {
      // 只支持参数注入，不支持属性注入
      Reflect.defineMetadata(
        CONTEXT_PARAM_KEY,
        parameterIndex,
        target,
        propertyKey,
      );
    };
  }
  ```

- [ ] **在 ParamBinder 中处理**
  - [ ] 识别 `@Context()` 装饰器标记的参数
  - [ ] 从 `AsyncLocalStorage` 获取当前请求的 Context 并注入
  - [ ] 添加类型定义和导出

**注意**：不支持属性注入，因为：

- 不利于解耦：属性注入会创建隐式依赖
- 可能造成滥用：容易在类中缓存 Context，导致并发问题
- 不符合依赖注入最佳实践：应该通过构造函数或方法参数注入

**优先级**：🟡 中\
**预计完成时间**：v1.2.1

---

## 📦 模块结构规划

### 新增文件

```
packages/bun-server/src/
├── core/
│   ├── context-service.ts     ✅ ContextService 实现（新建）
│   └── application.ts         ✅ 修改 handleRequest 方法
├── controller/
│   ├── decorators.ts          ✅ 添加 @Context() 装饰器
│   └── param-binder.ts        ✅ 处理 @Context() 参数注入
└── di/
    └── container.ts            ✅ 实现 Lifecycle.Scoped 支持
```

---

## 🎯 v1.2.0 发布标准

### 功能完整性

- [ ] **ContextService 实现完成**
  - [ ] AsyncLocalStorage 集成
  - [ ] ContextService 类实现
  - [ ] 自动注册到容器
  - [ ] 便捷方法实现（getHeader, getQuery, getParam 等）

- [ ] **@Context() 装饰器实现完成**
  - [ ] 装饰器定义
  - [ ] 参数绑定器支持
  - [ ] 类型定义和导出

### 稳定性

- [ ] **单元测试**
  - [ ] ContextService 单元测试
  - [ ] @Context() 装饰器测试
  - [ ] 请求作用域测试（如果实现）

- [ ] **集成测试**
  - [ ] 服务层访问 Context 测试
  - [ ] 拦截器中使用 ContextService 测试
  - [ ] 多个请求并发测试

- [ ] **性能测试**
  - [ ] AsyncLocalStorage 性能影响测试
  - [ ] ContextService 访问性能测试

- [ ] **无已知严重 Bug**

### 文档

- [ ] **使用文档**
  - [ ] ContextService 使用指南
  - [ ] @Context() 装饰器使用指南
  - [ ] 请求作用域使用指南（如果实现）

- [ ] **示例代码**
  - [ ] 基础使用示例
  - [ ] 服务层访问示例
  - [ ] 拦截器使用示例

---

## 📝 实现注意事项

### 1. AsyncLocalStorage 管理

- **框架统一管理**：框架内部创建和管理 `AsyncLocalStorage` 实例
- **请求级别隔离**：确保每个请求都有独立的上下文
- **性能考虑**：AsyncLocalStorage 性能开销较小，但需要验证

### 2. ContextService 设计

- **单例服务**：ContextService 本身是单例，但通过 AsyncLocalStorage
  获取请求级别的 Context
- **类型安全**：所有方法都有完整的类型定义
- **易于测试**：可以轻松 mock ContextService

### 3. @Context() 装饰器限制

- **仅支持参数注入**：不支持属性注入，避免隐式依赖和并发问题
- **明确依赖关系**：方法签名中明确显示需要 Context
- **符合 AOP 理念**：符合面向切面编程设计

### 4. 向后兼容

- **不影响现有功能**：新功能为可选使用，不影响现有代码
- **渐进式采用**：开发者可以选择使用 ContextService 或 @Context() 装饰器
- **现有代码无需修改**：不强制使用新功能

---

## 🔗 相关资源

- [v1.1.x Roadmap](./v1.1.x.md) - 自定义注解和拦截器机制
- [v1.x.x 汇总清单](./v1.x.x.md) - 所有待实现功能特性汇总
- [v1.3.x Roadmap](./v1.3.x.md) - 微服务架构支持（Nacos
  配置中心和服务注册与发现）
